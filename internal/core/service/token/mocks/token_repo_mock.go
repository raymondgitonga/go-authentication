// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package manager_mocks

import (
	"context"
	"github.com/raymondgitonga/go-authentication-service/internal/core/service/token"
	"sync"
)

// Ensure, that TokenRepositoryMock does implement TokenRepository.
// If this is not the case, regenerate this file with moq.
var _ manager.TokenRepository = &TokenRepositoryMock{}

// TokenRepositoryMock is a mock implementation of TokenRepository.
//
//	func TestSomethingThatUsesTokenRepository(t *testing.T) {
//
//		// make and configure a mocked TokenRepository
//		mockedTokenRepository := &TokenRepositoryMock{
//			AddTokenFunc: func(ctx context.Context, encryptionKey string, tokenID int64) error {
//				panic("mock out the AddToken method")
//			},
//			ClearExpiredTokensFunc: func(ctx context.Context) error {
//				panic("mock out the ClearExpiredTokens method")
//			},
//		}
//
//		// use mockedTokenRepository in code that requires TokenRepository
//		// and then make assertions.
//
//	}
type TokenRepositoryMock struct {
	// AddTokenFunc mocks the AddToken method.
	AddTokenFunc func(ctx context.Context, encryptionKey string, tokenID int64) error

	// ClearExpiredTokensFunc mocks the ClearExpiredTokens method.
	ClearExpiredTokensFunc func(ctx context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// AddToken holds details about calls to the AddToken method.
		AddToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// EncryptionKey is the encryptionKey argument value.
			EncryptionKey string
			// TokenID is the tokenID argument value.
			TokenID int64
		}
		// ClearExpiredTokens holds details about calls to the ClearExpiredTokens method.
		ClearExpiredTokens []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockAddToken           sync.RWMutex
	lockClearExpiredTokens sync.RWMutex
}

// AddToken calls AddTokenFunc.
func (mock *TokenRepositoryMock) AddToken(ctx context.Context, encryptionKey string, tokenID int64) error {
	if mock.AddTokenFunc == nil {
		panic("TokenRepositoryMock.AddTokenFunc: method is nil but TokenRepository.AddToken was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		EncryptionKey string
		TokenID       int64
	}{
		Ctx:           ctx,
		EncryptionKey: encryptionKey,
		TokenID:       tokenID,
	}
	mock.lockAddToken.Lock()
	mock.calls.AddToken = append(mock.calls.AddToken, callInfo)
	mock.lockAddToken.Unlock()
	return mock.AddTokenFunc(ctx, encryptionKey, tokenID)
}

// AddTokenCalls gets all the calls that were made to AddToken.
// Check the length with:
//
//	len(mockedTokenRepository.AddTokenCalls())
func (mock *TokenRepositoryMock) AddTokenCalls() []struct {
	Ctx           context.Context
	EncryptionKey string
	TokenID       int64
} {
	var calls []struct {
		Ctx           context.Context
		EncryptionKey string
		TokenID       int64
	}
	mock.lockAddToken.RLock()
	calls = mock.calls.AddToken
	mock.lockAddToken.RUnlock()
	return calls
}

// ClearExpiredTokens calls ClearExpiredTokensFunc.
func (mock *TokenRepositoryMock) ClearExpiredTokens(ctx context.Context) error {
	if mock.ClearExpiredTokensFunc == nil {
		panic("TokenRepositoryMock.ClearExpiredTokensFunc: method is nil but TokenRepository.ClearExpiredTokens was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClearExpiredTokens.Lock()
	mock.calls.ClearExpiredTokens = append(mock.calls.ClearExpiredTokens, callInfo)
	mock.lockClearExpiredTokens.Unlock()
	return mock.ClearExpiredTokensFunc(ctx)
}

// ClearExpiredTokensCalls gets all the calls that were made to ClearExpiredTokens.
// Check the length with:
//
//	len(mockedTokenRepository.ClearExpiredTokensCalls())
func (mock *TokenRepositoryMock) ClearExpiredTokensCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClearExpiredTokens.RLock()
	calls = mock.calls.ClearExpiredTokens
	mock.lockClearExpiredTokens.RUnlock()
	return calls
}
